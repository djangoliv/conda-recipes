diff --git modules/kernel/src/internal/directories.cpp modules/kernel/src/internal/directories.cpp
index 456a7fa..86c234e 100644
--- modules/kernel/src/internal/directories.cpp
+++ modules/kernel/src/internal/directories.cpp
@@ -28,73 +28,12 @@
 
 #include <cstdlib>
 
-#ifdef _MSC_VER
-#include <windows.h>
-
-// Registry functions are not in kernel but advapi32.dll
-#pragma comment(lib, "advapi32")
-#endif
-
 IMPKERNEL_BEGIN_INTERNAL_NAMESPACE
 extern std::string imp_data_path;
 extern std::string imp_example_path;
 
 namespace {
 
-#ifdef _MSC_VER
-// assume IMP version is the IMP::base version without any 'with' suffix
-std::string get_imp_version() {
-  std::string full_version = get_module_version();
-  size_t pos = full_version.find(" with");
-  if (pos != std::string::npos) {
-    full_version.resize(pos);
-  }
-  return full_version;
-}
-
-/** Get the directory where IMP is installed, by reading the
-    Windows registry key (set by the IMP binary installer).
-    \return true iff the registry key was found.
- */
-bool get_install_location(std::string &dir) {
-  // Only probe the registry once, then cache the value
-  static bool called, ret;
-  static std::string cached_dir;
-  if (called) {
-    if (ret) {
-      dir.assign(cached_dir);
-    }
-    return ret;
-  }
-
-  std::string version = get_imp_version();
-  std::string regkey = "SOFTWARE\\IMP-" + version;
-  HKEY key;
-  ret = false;
-
-  if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, regkey.c_str(), 0, KEY_READ, &key) ==
-      ERROR_SUCCESS) {
-    DWORD keylen, keytype;
-    if (RegQueryValueEx(key, "", nullptr, &keytype, nullptr, &keylen) ==
-            ERROR_SUCCESS &&
-        keytype == REG_SZ) {
-      char *keyval = new char[keylen];
-
-      if (RegQueryValueEx(key, "", nullptr, &keytype, (LPBYTE)keyval,
-                          &keylen) == ERROR_SUCCESS) {
-        dir.assign(keyval);
-        cached_dir.assign(keyval);
-        ret = true;
-      }
-      delete[] keyval;
-    }
-    RegCloseKey(key);
-  }
-  called = true;
-  return ret;
-}
-#endif
-
 std::string backup_search_path;
 
 Strings get_data_prefixes(std::string) {
@@ -107,18 +46,10 @@ Strings get_data_prefixes(std::string) {
       ret += cur;
     }
   }
-  {
-#ifdef _MSC_VER
-    // Since on Windows the IMP binary package is relocatable (the user
-    // can install it in any location), try this install location if available
-    // (the binary installer stores the location in the Windows registry)
-    std::string install_location;
-    if (get_install_location(install_location)) {
-      ret.push_back(install_location + "\\data");
-    }
-#endif
-  }
-  ret.push_back(imp_data_path);
+  // conda binary relocation sometimes adds trailing nulls to the data path,
+  // so remove any that crept in
+  ret.push_back(boost::trim_right_copy_if(imp_data_path,
+                                      boost::is_any_of(std::string("\0", 1))));
   if (!backup_search_path.empty()) {
     ret.push_back(backup_search_path);
   }
@@ -135,18 +66,8 @@ Strings get_example_prefixes(std::string) {
       ret += cur;
     }
   }
-  {
-#ifdef _MSC_VER
-    // Since on Windows the IMP binary package is relocatable (the user
-    // can install it in any location), try this install location if available
-    // (the binary installer stores the location in the Windows registry)
-    std::string install_location;
-    if (get_install_location(install_location)) {
-      ret.push_back(install_location + "\\examples");
-    }
-#endif
-  }
-  ret.push_back(imp_example_path);
+  ret.push_back(boost::trim_right_copy_if(imp_example_path,
+                                      boost::is_any_of(std::string("\0", 1))));
   if (!backup_search_path.empty()) {
     ret.push_back(backup_search_path);
   }
